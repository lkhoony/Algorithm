# 힙과 힙정렬

## Outline
- 힙
- 힙을 이용한 우선순위 큐 구현
- 힙 구현과 성능
- 힙 정렬
- 제자리 힙 정렬
- 상향식 힙 생성

## 1. 힙(Heap) ADT
> 완전 이진 트리의 일종으로 우선순위 큐를 위하여 만들어진 자료구조

### 1-1. 자료구조 힙(Heap)이란?
- 여러 개의 값들 중에서 최댓값이나 최솟값을 O(1)시간에 찾아내도록 만들어진 자료구조
- 반정렬 상태(느슨한 정렬 상태)를 유지한다.
```
- 부모 노드의 키 값이 자식 노드의 키 값보다 항상 큰(작은) 이진트리
```
- 힙 트리에서는 중복된 값을 허용

### 1-2. 힙의 종류
- 최대 힙(Max Heap) : 부모 노드의 키 값이 자식 노드의 키 값보다 크거나 같은 완전 이진 트리
- 최소 힙(Min Heap) : 부모 노드의 키 값이 자식 노드의 키 값보다 작거나 같은 완전 이진 트리

### 1-3. 힙의 높이
- N개의 키를 저장한 힙의 높이는 __O(log(N))__

## 2. 힙(Heap)을 이용한 우선순위 큐 구현
- 힙을 사용함으로써 우선순위 큐 구현 가능
- 각 내부 노드에 키를 우선순위에 따라 최대 힙, 혹은 최소 힙으로 저장
- 마지막 노드의 위치를 관리

## 3. 힙(Heap)구현과 성능

### 3-1. 힙의 구현
> 힙을 저장하는 표준적인 자료구조는 배열
- 구현을 용이하게 하기 위해 배열의 첫 번째 인덱스 0은 사용되지 않는다.
- i에 존재하는 노드에 대해서 왼쪽 자식은 2*i, 오른쪽 자식은 2*i+1에 존재하며 부모는 i/2에 존재

### 3-2. 힙 구현 메소드
#### 3-2-1. 힙의 삽입 (insertItem)
- 마지막 노드에 key를 삽입하고 힙 속성을 복구 시키는 과정으로 삽입이 진행됨
```
void insertItem(int key) {

  // n : 힙에 저장된 key의 갯수
  
	n++; // key가 삽입되기 때문에 n을 1 증가시킴
	H[n] = key; // 마지막 노드에 key를 삽입
	upHeap(n); // n번째 노드에서 힙의 속성을 복구시키는 upheap실행
	printf("0\n");
}
```

#### 3-2-2. 힙 삽입에서의 순서 속성 복구(upHeap)
- 새로운 키가 삽입된 후 힙 순서 속성이 위배될 수 있어 삽입된 노드로부터 상향 경로를 따라가며 키를 교환함으로써 힙 순서 속성 복구
- 최대힙(최소힙)일 경우 부모의 키가 새로운 키보다 클(작을)경우 정지
- 힙의 높이만큼 실행되기 때문에 upheap은 O(log(N))시간에 수행
```
void upHeap(int i) {
  
  // i=1, 즉 루트 노드의 인덱스일 경우 정지
	if (i == 1) {
		return;
	}
  
  // i번 째의 부모 노드, 즉 i/2번 째 노드의 키 값이 더 클 경우 정지
	if (H[i / 2] > H[i]) {
		return;
	}
  
  // 그렇지 않은 경우에는 부모 노드와 자리를 바꾸고 다시 upheap을 진행
	swapElement(&H[i / 2], &H[i]);
	upHeap(i / 2);
}
```

#### 3-2-3. 힙 삭제(removeMax)
- 최대(최소)힙에서 최대값(최소값)은 루트 노드기 때문에 루트 노드의 키를 반환하고 삭제함
- 삭제된 루트 노드를 마지막 노드의 키로 대체한 후 위배된 힙 순서 속성을 복구
```
void removeMax() {
  
	printf("%d\n", H[1]); // 루트 노드의 키를 출력
	H[1] = H[n]; // 루트 노드를 마지막 노드의 키로 대체
	n--; // 루트 노드 키가 삭제되었기 때문에 n을 1 감소
	downHeap(1); // 루트 노드에서 부터 힙 순서 속성을 복구
}
```
#### 3-2-4. 힙 삭제에서의 순서 속성 복구(downHeap)
- 루트에서 부터 하향 경로를 따라가며 키를 교환함으로써 힙 순서 속성을 복구
- 최대힙(최소힙)일 경우 부모의 키가 자식의 키보다 클(작을)경우 정지
- 힙의 높이만큼 실행되기 때문에 upheap은 O(log(N))시간에 수행
```
void downHeap(int i) {

	int biggerIndex;

	if (i * 2 > n) {
		return;
	} // i*2가 힙에 저장된 키의 갯수보다 크면 자식 노드가 없다는 것이기 떄문에 정지

	biggerIndex = i * 2; // 그렇지 않다면 왼쪽 자식은 있는 것이기 때문에 biggerIndex에 왼쪽 자식 노드 저장

	if (i * 2 + 1 <= n) { 
  // 만약 오른쪽 자식의 인덱스를 나타내는 i*2+1가 n보다 작거나 같으면 오른쪽 자식이 있는 것
		if (H[biggerIndex] < H[i * 2 + 1]) 
			biggerIndex = i * 2 + 1;	
      // 오른쪽 자식의 키가 왼쪽 자식 키 보다 크면 biggerIndex에 오른쪽 자식을 저장
	}
  
  // 만약 부모 노드보다 자식 노드가 더 크면 키를 서로 교환
	if (H[i] < H[biggerIndex]) {
		swapElement(&H[i], &H[biggerIndex]);
	}
  
  // 자식노드의 위치에서 downHeap을 다시 한번 
	downHeap(biggerIndex);
	
}
```

## 4. 힙(Heap) 정렬
> 배열을 힙(heap) 순서 속성을 복구하고 최대힙, 최소힙에 따라 오름차순 혹은 내림차순으로 정렬하는 과정
- 제자리 힙 정렬은 heap sort의 공간 사용을 줄인다.
- 상향식 힙 생성은 heap sort의 속도를 높인다.

## 5. 제자리 힙(Heap) 정렬
- 정렬되어야 할 리스트가 배열로 주어진 경우에만 적용
- 힙을 저장하는데 리스트 L의 일부를 사용함으로써 외부 힙 사용을 피함

### 5.1. 제자리 힙(Heap) 정렬 과정
> 배열을 힙(Heap) 속성을 복구하는 과정 이후 오름차순, 혹은 내림차순으로 정렬하는 순으로 실행

#### 5.1.1. 상향식 힙 생성
> O(N)시간에 수행하는 상향식 힙 생성 방식으로 속도를 높임
- N회의 insertItem작업을 하여 힙을 생성하면 O(N*logN)시간이 걸림
- 힙에 저장될 모든 키들이 미리 주어진다면 O(N)시간에 수행하는 상향식 생성 방식을 사용
- 재귀적인 방식과 비 재귀적인 방식이 있지만 두 방식 다 O(N)시간에 수행
```
// # 재귀적인 방법
void rBuildHeap(int i) {

	if (i > n) {
		return;
	}

	rBuildHeap(2 * i);
	rBuildHeap(2 * i + 1);
	downHeap(i);
}

// # 비재귀적인 방법
void buildHeap() {
	for (int i = n / 2; i >= 1; i--) {
		downHeap(i);
	}
}
```
- 왜 실행시간 O(N)이 나오는가?
```
잎새 노드가 있는 레벨을 d라고 하면
- 레벨이 d인 노드들의 갯수 : n/2개, downHeap수행 횟수 : 0번
- 레벨이 d-1인 노드들의 갯수 : n/4개 (나머지 n/2중 1/2), downHeap 수행 횟수 : 1번
- 레벨에 d-2인 노드들의 갯수 : n/8개 (나머지 n/4중 1/2), downHeap 수행 횟수 : 2번
- 총 수행 횟수 = n/2 * 0 + n/4 * 1 + n/8 * 2.... = n/4 * (1 + 2* 1/2 + 3 * 1/4 + ...) = n/4 * c = O(N) 
```

#### 5.2.2. 힙 정렬(Heap Sort)
- 주어진 원소들로 상향식 힙생성으로 힙 구조 생성
- 최대 힙의 루트노드(=현재 배열의 첫번째 요소=최댓값)와 말단노드(=현재 배열의 마지막 요소)를 교환
- 새 루트노드에 대해 최대 힙을 구성하는 과정 반복
