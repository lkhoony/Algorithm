# 우선순위 큐

## Outline
- 우선순위 큐 ADT
- 우선순위 큐를 이용한 정렬
- 제자리 정렬
- 선택 정렬과 삽입 정렬 비교

## 1. 우선순위 큐(Priory Queue) ADT

> 큐(Queue)는 연산의 결과로 먼저 들어간 데이터가 먼저 나오나(First In First Out) 
우선순위 큐(Priority Queue)에서는 우선순위가 높은 데이터가 먼저 나온다.

### 1-1 우선순위 큐 ADT 메소드
  - insertItem(k,e) : 키 k인 원소 e를 큐에 삽입
  - removeMin() : 큐로부터 최소 키를 가진 원소를 삭제하여 반환
  - minElement() : 큐에서 최소 키를 가진 원소를 삭제하지 않고 반환
  - minKey() : 큐에서 최소 키를 반환
  - size() : 큐의 항목 수를 반환
  
## 2. 우선순위 큐를 이용한 정렬
> 정렬되지 않은 리스트(L)에서 첫 번째 원소들을 연속적으로 제거하여 이를 insertItem(e,e)메소드를 호출하여 원소들을 우선순위 큐(PQ)에 삽입하고 
다시 우선순위 큐에서 removeMin() 메소드를 호출하여 원소들을 다시 리스트(L)에 삽입

### 2-1 리스트에 기초한 우선순위 큐
  #### 2-1-1 우선순위 큐(PQ)를 무순리스트로 구현
  - 우선순위 큐를 리스트에 임의 순서대로 저장하는 무순리스트로 구현할 경우 삽입 연산의 경우 순서가 상관 없기 때문에 O(1)이 소요되지만 
  최소 키를 찾을 때 전체 리스트를 순회해야하기 때문에 O(N)시간이 소요
  ```
  - insertItem : O(1)
  - removeMin, minKey, minElement : O(N)
  ```
  
  #### 2-1-2 우선순위 큐(PQ)를 순서리스트로 구현
  - 우선순위 큐를 리스트에 키 정렬순서대로 저장하는 순서리스트로 구현할 경우 삽입 연산때 순서를 결정하기 위해 순회하기 떄문에 O(N)이 소요되지만 
  최소 키는 맨 앞에 정렬되기 때문에 O(1)시간이 소요
  ```
  - insertItem : O(N)
  - removeMin, minKey, minElement : O(1)
  ```
  
  #### 2-1-3 선택정렬(Selection Sort)
  > 우선순위 큐가 무순리스트로 구현되었을 때 L에서 PQ를 이용한 PQ-Sort는 선택정렬을 수행
  - N회의 insertItem 메소드를 호출하여 원소를 PQ에 삽입 : O(N)시간 소요
  - N회의 removeMin 메소드를 호출하여 PQ로 부터 우선순위에 따라 삭제 : O(N^2)시간 소요 (원소를 순회하면서 우선순위를 비교해야 하기 때문)
  - 실행시간 : O(N^2)
  
  #### 2-1-4 삽입정렬(Selection Sort)
  > 우선순위 큐가 순서리스트로 구현되었을 때 L에서 PQ를 이용한 PQ-Sort는 삽입정렬을 수행
  - N회의 insertItem 메소드를 호출하여 원소를 PQ에 삽입 : O(N^2)시간 소요 (PQ의 키를 순회하면서 순서대로 정렬해야 하기 때문)
  - N회의 removeMin 메소드를 호출하여 PQ로 부터 우선순위에 따라 삭제 : O(N)시간 소요 (PQ는 정렬되어있기 때문)
  - 실행시간 : O(N^2)
  
### 3. 제자리 정렬
> 2와 같이 PQ 리스트를 새로 구현하여 정렬을 하게되면 추가적인 메모리 공간이 필요하기 때문에 주어진 리스트(L)에서 추가적인 공간(PQ)없이 정렬을 수행하는 것
  #### 3-1-1 제자리 선택정렬
  - 해당 순서에 원소를 넣을 위치는 정해져 있고 그 원소를 찾는 정렬
  ```
  for (int i = 0; i < N - 1; i++) {
		minLoc = i;
		for (int j = i + 1; j < N; j++) {
			if (intArr[minLoc] > intArr[j])
				minLoc = j;
		}
		swap(intArr + i, intArr + minLoc);
	}
  ```
  #### 3-1-2 제자리 삽입정렬
  -  자료 배열의 모든 요소를 앞에서부터 차례대로 이미 정렬된 배열 부분과 비교하여, 자신의 위치를 찾아 삽입함으로써 정렬을 완성하는 알고리즘
  ```
  for (int i = 1; i < N; i++) {
		j = i - 1;
		save = intArr[i];
		while (j >= 0 && intArr[j] > save) {
			intArr[j + 1] = intArr[j];
			j--;
		}
		intArr[j + 1] = save;
	}
  ```
